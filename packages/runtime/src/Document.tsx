import * as React from 'react';
import { useAppContext } from './AppContext.js';
import type { AssetsManifest, RouteMatch } from './types';

export function Meta() {
  const { pageData } = useAppContext();
  const meta = pageData.pageConfig.meta || [];

  return (
    <>
      {meta.map(item => <meta key={item.name} {...item} />)}
      <meta
        name="ice-meta-count"
        content={meta.length.toString()}
      />
    </>
  );
}

export function Title() {
  const { pageData } = useAppContext();
  const title = pageData.pageConfig.title || [];

  return (
    <title>{title}</title>
  );
}

export function Links() {
  const { pageData, matches, assetsManifest } = useAppContext();

  const customLinks = pageData.pageConfig.links || [];

  const pageAssets = getPageAssets(matches, assetsManifest);
  const entryAssets = getEntryAssets(assetsManifest);
  const styles = pageAssets.concat(entryAssets).filter(path => path.indexOf('.css') > -1);

  return (
    <>
      {
        customLinks.map(link => {
          const { block, ...props } = link;
          return <link key={link.href} {...props} />;
        })
      }
      {styles.map(style => <link key={style} rel="stylesheet" type="text/css" href={style} />)}
    </>
  );
}

export function Scripts() {
  const { pageData, initialData, matches, assetsManifest } = useAppContext();

  const pageAssets = getPageAssets(matches, assetsManifest);
  const entryAssets = getEntryAssets(assetsManifest);

  const { scripts: customScripts = [] } = pageData.pageConfig;

  const scripts = pageAssets.concat(entryAssets).filter(path => path.indexOf('.js') > -1);

  const appContext = {
    initialData,
    pageData,
    assetsManifest,
  };

  return (
    <>
      <script dangerouslySetInnerHTML={{ __html: `window.__ICE_APP_CONTEXT__=${JSON.stringify(appContext)}` }} />
      {
        customScripts.map(script => {
          const { block, ...props } = script;
          return <script key={script.src} defer {...props} />;
        })
      }
      {/*
       * Script must be deferred.
       * If there are other dom after this tag, and hydrate before parsed all dom,
       * hydrate will fail due to inconsistent dom nodes.
       */}
      {
        scripts.map(script => {
          return <script key={script} defer src={script} />;
        })
      }
    </>
  );
}

export function Main(props) {
  const { isSSR, isSSG } = useAppContext();

  const renderBySSR = isSSR || isSSG;

  // Disable hydration warning for pages not from ssr.
  // If page html is not generated by SSR, content form "ice-container" is empty.
  return (
    <div id="ice-container" suppressHydrationWarning={!renderBySSR} >
      {props.children}
    </div>
  );
}

/**
 * merge assets info for matched page
 */
 export function getPageAssets(matches: RouteMatch[], assetsManifest: AssetsManifest): string[] {
  const { pages, publicPath } = assetsManifest;

  let result = [];

  matches.forEach(match => {
    const { componentName } = match.route;
    const assets = pages[componentName];
    assets && assets.forEach(filePath => {
      result.push(`${publicPath}${filePath}`);
    });
  });

  return result;
}

export function getEntryAssets(assetsManifest: AssetsManifest): string[] {
  const { entries, publicPath } = assetsManifest;
  let result = [];

  Object.values(entries).forEach(assets => {
    result = result.concat(assets);
  });

  return result.map(filePath => `${publicPath}${filePath}`);
}